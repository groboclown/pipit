#!/usr/bin/python3

"""
Read in the aws-sdk API json files and create the skeleton
API code.
"""

import os
import sys
import json
import re

PAGINATOR_FORMAT = re.compile(r'^([^-]+)-(\d\d\d\d-\d\d-\d\d).paginators.json$')
API_FORMAT = re.compile(r'^([^-]+)-(\d\d\d\d-\d\d-\d\d).min.json$')


def build_file(outdir, api_entry):
    if api_entry["api"] is None:
        load_api(api_entry)
        if api_entry["api"] is None:
            # Skip
            return
    api_dir = os.path.join(outdir, api_entry["api"]["metadata"]["endpointPrefix"])
    if not os.path.isdir(api_dir):
        os.makedirs(api_dir)
    with open(os.path.join(api_dir, 'boilerplate-' +  api_entry["api"]["metadata"]["apiVersion"] + '.js'), 'w') as f:
        f.write(build_file_text(api_entry))


def build_file_text(api_entry):
    namespace = (
            "xmlNamespace" in api_entry["api"]["metadata"]
                and "'" + api_entry["api"]["metadata"]["xmlNamespace"] + "'"
        ) or 'null'
    ret = """'use strict';

const awsCommon = require('../../lib/aws-common');

/**
 * {0} version {1}
 *
 * --- TODO REMOVE WHEN IMPLEMENTED ---
 * AUTOGENERATED BY build-api.py
 */

// Setup input and output to use AWS protocol {2}
require('../../lib/aws-common/shape_http')('{2}', module.exports, {3});
""".format(
            api_entry["api"]["metadata"]["serviceFullName"],
            api_entry["api"]["metadata"]["apiVersion"],
            api_entry["api"]["metadata"]["protocol"],
            namespace)
    # Note: sort the keys so it's easy to diff with upgrades.
    api_entry_keys = list(api_entry["api"]["operations"].keys())
    api_entry_keys.sort()
    for operation_name in api_entry_keys:
        ret += build_action(operation_name, api_entry["api"])

    return ret


def build_action(operation_name, api):
    ret = '// -----------------------------------\nmodule.exports.' + operation_name + ' = '
    operation = api["operations"][operation_name]
    end = '}'
    indent = '  '
    if "http" in operation:
        ret += 'awsCommon.as(\n'
        if "method" in operation["http"]:
            ret += "  '" + operation["http"]["method"] + "',\n"
            if "requestUri" not in operation["http"]:
                # we need a request URI to work this API right.
                print(" - has no requestUri: {0}".format(operation_name))
                operation["http"]["requestUri"] = '/'
        # the {asdf} translates into :asdf
        ret += "  '" + operation["http"]["requestUri"].replace("{", ":").replace("}", "") + "',\n  "
        end = '  })'
        indent = '    '
    ret += 'function ' + operation_name + '(aws) {\n'
    ret += build_arguments(operation_name, api, indent)
    ret += '\n\n' + indent + '// TODO implement code\n\n'
    ret += build_return(operation_name, api, indent)
    retcode = '200'
    if "http" in operation and "responseCode" in operation["http"]:
        retcode = operation["http"]["responseCode"]
    # retcode may have been parsed as a number
    ret += indent + 'return [{0}, ret];\n'.format(retcode)
    ret += end + ';\n'
    return ret


def build_arguments(operation_name, api, indent):
    """Constructs the input arguments."""
    ret = ''
    if "input" in api["operations"][operation_name]:
        if "members" in api["operations"][operation_name]["input"]:
            # Note: sorting members, so future diffs are easy
            member_names = list(api["operations"][operation_name]["input"]["members"].keys())
            member_names.sort()
            for k in member_names:
                v = api["operations"][operation_name]["input"]["members"][k]
                vname = as_js_variable(k)
                if "location" in v and v["location"] == 'uri':
                    # It's in the actual url path
                    if must_be_quoted(v["locationName"]):
                        ret += indent + 'var ' + vname + " = aws.reqParams['" + v["locationName"] + "']"
                    else:
                        ret += indent + 'var ' + vname + " = aws.reqParams." + v["locationName"]
                elif "location" in v and v["location"] == 'querystring':
                    # in the query string; should be the "params" due to some smarts
                    if "http" in api and "method" in api["http"] and api["http"]["method"] != 'GET':
                        raise Exception(operation_name + ' has non-GET with querystring parameters')
                    if must_be_quoted(k):
                        ret += indent + 'var ' + vname + " = aws.params['" + k + "']"
                    else:
                        ret += indent + 'var ' + vname + " = aws.params." + k
                elif must_be_quoted(k):
                    ret += indent + 'var ' + vname + " = aws.params['" + k + "']"
                else:
                    ret += indent + 'var ' + vname + " = aws.params." + k
                if "type" in v:
                    ret += ' /* Type ' + v["type"] + ' */'
                ret += ';\n'
        if "required" in api["operations"][operation_name]["input"]:
            # Note: sort for ease of diff.
            required_keys = list(api["operations"][operation_name]["input"]["required"])
            required_keys.sort()
            for k in required_keys:
                vname = as_js_variable(k)
                ret += (indent + 'if (!' + vname + ') {\n' +
                    indent + "  return [400, 'Sender', 'MissingParameter', 'Did not specify parameter " + k + "'];\n" +
                    indent + '}\n')
    return ret


VALID_JS_FIELD = re.compile(r'^[A-Za-z0-9]+$')
def must_be_quoted(key):
    return VALID_JS_FIELD.match(key) is None


def as_js_variable(key):
    # Replace _x with X, and force the first letter to be lower case
    ok = key
    key = ""
    first = True
    next_cap = False
    for c in ok:
        if first:
            first = False
            c = c.lower()
        if next_cap:
            next_cap = False
            c = c.upper()
        if c == '_':
            next_cap = True
        else:
            key += c

    # Ensure we don't have js keywords as variable names.
    if key in ['return', 'switch', 'case', 'if', 'else', 'for', 'delete'] or not key[0].isidentifier():
        key = '_' + key

    return key


def build_return(operation_name, api, indent):
    """Constructs the empty return value."""
    if "output" in api["operations"][operation_name]:
        shape = api["operations"][operation_name]["output"]
        return indent + "var ret = " + build_return_shape(indent, shape, api) + ';\n'
    else:
        # print(" - no output for " + operation_name)
        return indent + "var ret = {};\n"

def build_return_shape(indent, shape, api, found=None):
    if found is None:
        found = {}
    if shape is None:
        return "''"
    if "shape" in shape:
        if shape["shape"] in found:
            if found[shape["shape"]] is None:
                return "null /* Recursive {0}*/".format(shape["shape"])
            return found[shape["shape"]]
        found[shape["shape"]] = None
        ret = "/*{0}*/{1}".format(shape["shape"],
            build_return_shape(
                indent, find_shape(shape["shape"], api), api, found))
        found[shape["shape"]] = ret
        return ret
    if "type" not in shape or shape["type"] == 'string':
        return "''"
    if shape["type"] == 'list':
        return '[ ' + build_return_shape(indent, shape["member"], api, found) + ', /* ...*/ ]'
    if shape["type"] == 'structure':
        ret = '{\n'
        members = []
        # Note: sort for ease of diffs
        member_keys = list(shape["members"].keys())
        member_keys.sort()
        for k in member_keys:
            v = shape["members"][k]
            members.append(indent + '  ' + k + ': ' + build_return_shape(indent + '  ', v, api, found) + ',')
        return '{\n' + "\n".join(members) + '\n' + indent + '}'
    if shape["type"] == 'map':
        # simple map???
        return '{} /*Map*/'
    if shape["type"] == 'integer':
        return '0'
    if shape["type"] == 'long':
        return '0 /*Long*/'
    if shape["type"] == 'double':
        return '0.0 /*Double*/'
    if shape["type"] == 'float':
        return '9.0'
    if shape["type"] == 'timestamp':
        return 'awsCommon.timestamp()'
    if shape["type"] == 'boolean':
        return 'false'
    if shape["type"] == 'blob':
        return 'null /*Blob*/'

    raise Exception('unknown shape type ' + shape["type"])

def find_shape(shape_name, api):
    if shape_name in api["shapes"]:
        return api["shapes"][shape_name]
    return None

GENERAL_VERSION_PATH = re.compile("^/(\d\d\d\d-\d\d-\d\d)/")
def build_requires_list(api_name, version_entries):
    versions = {}
    alt_versions = {}
    has_no_version_uri_count = 0
    version_count = 0
    # Check how many versions have URI paths
    # This is constructing the alt version list, so sorting isn't necessary
    for version, api_entry in version_entries.items():
        versionPath = re.compile("^/" + version + "/")
        versions[version] = True
        version_count += 1
        #print(repr(api_entry))
        for api, decl in api_entry["api"]["operations"].items():
            if "http" in decl and "requestUri" in decl["http"]:
                if versionPath.match(decl["http"]["requestUri"]) is not None:
                    # current version path
                    if version not in alt_versions:
                        alt_versions[version] = []
                    if version not in alt_versions[version]:
                        alt_versions[version].append(version)
                    continue
                match = GENERAL_VERSION_PATH.match(decl["http"]["requestUri"])
                if match is not None:
                    # interesting situation: different (older) API supported in
                    # the current API.  The normalize version actually fully supports
                    # this.
                    print("**** {0} [{2}][{1}] has different version {3}".format(
                        api_name, version, api, match.group(1)))
                    if match.group(1) in alt_versions and alt_versions[match.group(1)] != version:
                        # Use the highest matching real version
                        if match.group(1) not in alt_versions:
                            alt_versions[match.group(1)] = []
                        if version not in alt_versions[match.group(1)]:
                            alt_versions[match.group(1)].append(version)
                    else:
                        if match.group(1) not in alt_versions:
                            alt_versions[match.group(1)] = []
                        alt_versions[match.group(1)].append(version)
                    continue

            # not a version API
            versions[version] = False
            has_no_version_uri_count += 1
            break
    if (has_no_version_uri_count >= version_count) or (has_no_version_uri_count > 1):
        # Just use the highest version number

        highest_version = None
        for version in version_entries.keys():
            if highest_version is None:
                highest_version = version
            elif highest_version < version:
                highest_version = version
        ret = ["'/{0}': normalize(require('./{0}/boilerplate-{1}.js'))".format(
            api_name, version)]
    else:
        # Each version is its own path
        ret = []
        # Sort for ease of diff
        path_version_keys = list(alt_versions.keys())
        path_version_keys.sort()
        for path_version in path_version_keys:
            real_version_list = alt_versions[path_version]
            if path_version in versions and not versions[path_version]:
                if len(real_version_list) > 1:
                    raise Exception("{0} has path version {1} which is not versioned, but it has multiple API versions mapped to it ({2})".format(
                        api_name, path_version, repr(real_version_list)))
                ret.append("'/{0}': normalize(require('./{0}/boilerplate-{1}.js'))".format(
                    api_name, version))
            else:
                # Make sure earlier real versions appear first.
                real_version_list.sort()
                req_list = []
                for v in real_version_list:
                    req_list.append("require('./{0}/boilerplate-{1}.js')".format(
                        api_name, v))
                ret.append("'/{0}/{1}': normalizeVersions('{1}', [{2}])".format(
                    api_name, path_version, ", ".join(req_list)))
    if len(ret) <= 0:
        raise Exception("no urls registered for " + api_name)
    return ret



def build_route_file(outdir, api_version_entries):
    routeList = []
    for api_name, version_entries in api_version_entries.items():
        routeList.extend(build_requires_list(api_name, version_entries))
    # Note: sort for ease of diff
    routeList.sort()

    with open(os.path.join(outdir, 'boilerplate-routes.js'), 'w') as f:
        f.write("""'use strict';

const normalize = require('../lib/aws-common/normalize-route');
const normalizeVersions = normalize.normalizeVersions;

/**
* Maps the route from the URL path to the service's ActionMap.
* ----- AUTO-GENERATED CODE -----
*/
module.exports = {
  """ + ",\n  ".join(routeList) + """,
};""")


def load_api(api_entry):
    print(api_entry["api_file"])
    with open(api_entry["api_file"], 'r') as f:
        api_entry["api"] = json.load(f)
        # if "version" not in api_entry["api"]:
        #     print("  - unsupported file version (<= 1.0)")
        #     return None
        # if api_entry["api"]["version"] != '2.0':
        #     print("  - unsupported file version " + api_entry["api"]["version"])
        #     return None
    if api_entry["paginator_file"] is not None:
        with open(api_entry["paginator_file"], 'r') as f:
            api_entry["paginator"] = json.load(f)


def create_api_entry(api_map, api_name, api_version):
    if api_name not in api_map:
        api_map[api_name] = {}
    if api_version not in api_map[api_name]:
        api_map[api_name][api_version] = {
            "name": api_name,
            "version": api_version,
            "paginator": None,
            "api": None,
            "paginator_file": None,
            "api_file": None
        }
    return api_map[api_name][api_version]


def find_files(api_dir):
    ret = {}
    files = os.listdir(api_dir)
    for f in files:
        full_path = os.path.join(api_dir, f)
        match = PAGINATOR_FORMAT.match(f)
        if match:
            entry = create_api_entry(ret, match.group(1), match.group(2))
            entry["paginator_file"] = full_path
        match = API_FORMAT.match(f)
        if match:
            entry = create_api_entry(ret, match.group(1), match.group(2))
            entry["api_file"] = full_path
    return ret


def build_all_files(outdir, api_dir):
    api_entries = find_files(api_dir)
    # No need to sort, because this is just building each file (which is diffed independently)
    for api_name, versions in api_entries.items():
        for api_version, api_entry in versions.items():
            build_file(outdir, api_entry)
    build_route_file(outdir, api_entries)


if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("Usage: {0} (api dir) (output dir)".format(sys.argv[0]))
    else:
        build_all_files(sys.argv[2], sys.argv[1])
