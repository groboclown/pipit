#!/usr/bin/python3

"""
Read in the aws-sdk API json files and create the skeleton
API code.
"""

import os
import sys
import json
import re

PAGINATOR_FORMAT = re.compile(r'^([^-]+)-(\d\d\d\d-\d\d-\d\d).paginators.json$')
API_FORMAT = re.compile(r'^([^-]+)-(\d\d\d\d-\d\d-\d\d).min.json$')


def build_file(outdir, api_entry):
    if api_entry["api"] is None:
        load_api(api_entry)
        if api_entry["api"] is None:
            # Skip
            return
    api_dir = os.path.join(outdir, api_entry["api"]["metadata"]["endpointPrefix"])
    if not os.path.isdir(api_dir):
        os.makedirs(api_dir)
    with open(os.path.join(api_dir, 'boilerplate-' +  api_entry["api"]["metadata"]["apiVersion"] + '.js'), 'w') as f:
        f.write(build_file_text(api_entry))


def build_file_text(api_entry):
    ret = """'use strict';
const aws_common = require('../../lib/aws-common');


/**
 * {0} version {1}
 *
 * --- TODO REMOVE WHEN IMPLEMENTED ---
 * AUTOGENERATED BY build-api.py
 */
""".format(
            api_entry["api"]["metadata"]["serviceFullName"],
            api_entry["api"]["metadata"]["apiVersion"])
    for operation_name in api_entry["api"]["operations"].keys():
        ret += build_action(operation_name, api_entry["api"])

    return ret


def build_action(operation_name, api):
    ret = 'module.exports.' + operation_name + ' = '
    operation = api["operations"][operation_name]
    end = '}'
    if "http" in operation:
        ret += 'aws_common.as(\n'
        if "method" in operation["http"]:
            ret += '    "' + operation["http"]["method"] + '",\n'
            if "requestUri" not in operation["http"]:
                # we need a request URI to work this API right.
                print(" - has no requestUri: {0}".format(operation_name))
                operation["http"]["requestUri"] = '/'
        # the {asdf} translates into :asdf
        ret += '    "' + operation["http"]["requestUri"].replace("{", ":").replace("}", "") + '",\n    '
        end += ');'
    ret += 'function ' + operation_name + '(aws) {\n'
    ret += build_arguments(operation_name, api)
    ret += '\n\n        // TODO implement code\n\n'
    ret += build_return(operation_name, api)
    retcode = '200'
    if "http" in operation and "responseCode" in operation["http"]:
        retcode = operation["http"]["responseCode"]
    # retcode may have been parsed as a number
    ret += '        return [{0}, ret];\n'.format(retcode)
    ret += '    ' + end + '\n'
    return ret


def build_arguments(operation_name, api):
    """Constructs the input arguments."""
    ret = ''
    indent = '        '
    if "input" in api["operations"][operation_name]:
        if "members" in api["operations"][operation_name]["input"]:
            for k, v in api["operations"][operation_name]["input"]["members"].items():
                vname = asJsVariable(k)
                if "location" in v and v["location"] == 'uri':
                    # It's in the actual url path
                    ret += indent + 'var ' + vname + " = aws.reqParams." + v["locationName"]
                elif "location" in v and v["location"] == 'querystring':
                    # in the query string; should be the "params" due to some smarts
                    if "http" in api and "method" in api["http"] and api["http"]["method"] != 'GET':
                        raise Exception(operation_name + ' has non-GET with querystring parameters')
                    ret += indent + 'var ' + vname + " = aws.params['" + k + "']"
                else:
                    ret += indent + 'var ' + vname + " = aws.params['" + k + "']"
                if "type" in v:
                    ret += ' /* ' + v["type"] + ' */'
                ret += ';\n'
        if "required" in api["operations"][operation_name]["input"]:
            for k in api["operations"][operation_name]["input"]["required"]:
                ret += (indent + 'if (! ' + k + ') {\n' +
                    indent + '    return [400, "Sender", "MissingParameter", "Did not specify parameter ' + k + '"];\n' +
                    indent + '}')
    return ret


def asJsVariable(key):
    if key in ['return', 'switch', 'case', 'if', 'else', 'for'] or not key[0].isidentifier():
        return '_' + key

    return key


def build_return(operation_name, api):
    """Constructs the empty return value."""
    if "output" in api["operations"][operation_name]:
        shape = api["operations"][operation_name]["output"]
        return "        var ret = " + build_return_shape('        ', shape, api) + ';\n'
    else:
        # print(" - no output for " + operation_name)
        return "        var ret = {};\n"

def build_return_shape(indent, shape, api, found=None):
    if found is None:
        found = {}
    if shape is None:
        return '""'
    if "shape" in shape:
        if shape["shape"] in found:
            if found[shape["shape"]] is None:
                return "null/* recursive {0}*/".format(shape["shape"])
            return found[shape["shape"]]
        found[shape["shape"]] = None
        ret = "/*{0}*/{1}".format(shape["shape"],
            build_return_shape(
                indent, find_shape(shape["shape"], api), api, found))
        found[shape["shape"]] = ret
        return ret
    if "type" not in shape or shape["type"] == 'string':
        return '""'
    if shape["type"] == 'list':
        return '[ ' + build_return_shape(indent, shape["member"], api, found) + ' /*, ...*/ ]'
    if shape["type"] == 'structure':
        ret = '{\n'
        members = []
        for k, v in shape["members"].items():
            members.append(indent + '    ' + k + ': ' + build_return_shape(indent + '    ', v, api, found))
        return '{\n' + ",\n".join(members) + '\n' + indent + '}'
    if shape["type"] == 'map':
        # simple map???
        return '{} /* map */'
    if shape["type"] == 'integer':
        return '0'
    if shape["type"] == 'long':
        return '0 /*long*/'
    if shape["type"] == 'double':
        return '0.0 /*double*/'
    if shape["type"] == 'float':
        return '9.0'
    if shape["type"] == 'timestamp':
        return 'now()'
    if shape["type"] == 'boolean':
        return 'false'
    if shape["type"] == 'blob':
        return 'null /*blob*/'

    raise Exception('unknown shape type ' + shape["type"])

def find_shape(shape_name, api):
    if shape_name in api["shapes"]:
        return api["shapes"][shape_name]
    return None

GENERAL_VERSION_PATH = re.compile("^/(\d\d\d\d-\d\d-\d\d)/")
def build_requires_list(api_name, version_entries):
    versions = {}
    alt_versions = {}
    has_no_version_uri_count = 0
    version_count = 0
    # Check how many versions have URI paths
    for version, api_entry in version_entries.items():
        versionPath = re.compile("^/" + version + "/")
        versions[version] = True
        version_count += 1
        #print(repr(api_entry))
        for api, decl in api_entry["api"]["operations"].items():
            if "http" in decl and "requestUri" in decl["http"]:
                if versionPath.match(decl["http"]["requestUri"]) is not None:
                    # current version path
                    if version not in alt_versions:
                        alt_versions[version] = []
                    if version not in alt_versions[version]:
                        alt_versions[version].append(version)
                    continue
                match = GENERAL_VERSION_PATH.match(decl["http"]["requestUri"])
                if match is not None:
                    # interesting situation: different (older) API supported in
                    # the current API.  The normalize version actually fully supports
                    # this.
                    print("**** {0} [{2}][{1}] has different version {3}".format(
                        api_name, version, api, match.group(1)))
                    if match.group(1) in alt_versions and alt_versions[match.group(1)] != version:
                        # Use the highest matching real version
                        if match.group(1) not in alt_versions:
                            alt_versions[match.group(1)] = []
                        if version not in alt_versions[match.group(1)]:
                            alt_versions[match.group(1)].append(version)
                    else:
                        if match.group(1) not in alt_versions:
                            alt_versions[match.group(1)] = []
                        alt_versions[match.group(1)].append(version)
                    continue

            # not a version API
            versions[version] = False
            has_no_version_uri_count += 1
            #### DEBUG
            if api_name == 'lambda':
                print("**** lambda [{1}][{0}]: not versioned".format(api, version))
            #### DEBUG
            break
    if (has_no_version_uri_count >= version_count) or (has_no_version_uri_count > 1):
        # Just use the highest version number

        #### DEBUG
        if api_name == 'lambda':
            print("**** lambda: lots of no version uris: " + repr(versions))
        #### DEBUG

        highest_version = None
        for version in version_entries.keys():
            if highest_version is None:
                highest_version = version
            elif highest_version < version:
                highest_version = version
        ret = ["'/{0}': normalize(require('./{0}/boilerplate-{1}.js'))".format(
            api_name, version)]
    else:
        # Each version is its own path
        ret = []
        for path_version, real_version_list in alt_versions.items():
            if path_version in versions and not versions[path_version]:
                if len(real_version_list) > 1:
                    raise Exception("{0} has path version {1} which is not versioned, but it has multiple API versions mapped to it ({2})".format(
                        api_name, path_version, repr(real_version_list)))
                ret.append("'/{0}': normalize(require('./{0}/boilerplate-{1}.js'))".format(
                    api_name, version))
            else:
                # Make sure earlier real versions appear first.
                real_version_list.sort()
                req_list = []
                for v in real_version_list:
                    req_list.append("require('./{0}/boilerplate-{1}.js')".format(
                        api_name, v))
                ret.append("'/{0}/{1}': normalizeVersions('{1}', [{2}])".format(
                    api_name, path_version, ", ".join(req_list)))
    if len(ret) <= 0:
        raise Exception("no urls registered for " + api_name)
    return ret



def build_route_file(outdir, api_version_entries):
    routeList = []
    for api_name, version_entries in api_version_entries.items():
        routeList.extend(build_requires_list(api_name, version_entries))
    routeList.sort()

    with open(os.path.join(outdir, 'boilerplate-routes.js'), 'w') as f:
        f.write("""
'use strict';
const normalize = require('../lib/aws-common/normalize-route');
const normalizeVersions = normalize.normalizeVersions;

/**
 * Maps the route from the URL path to the service's ActionMap.
 * ----- AUTO-GENERATED CODE -----
 */
module.exports = {
    """ + ",\n    ".join(routeList) + """
};""")


def load_api(api_entry):
    print(api_entry["api_file"])
    with open(api_entry["api_file"], 'r') as f:
        api_entry["api"] = json.load(f)
        # if "version" not in api_entry["api"]:
        #     print("  - unsupported file version (<= 1.0)")
        #     return None
        # if api_entry["api"]["version"] != '2.0':
        #     print("  - unsupported file version " + api_entry["api"]["version"])
        #     return None
    if api_entry["paginator_file"] is not None:
        with open(api_entry["paginator_file"], 'r') as f:
            api_entry["paginator"] = json.load(f)


def create_api_entry(api_map, api_name, api_version):
    if api_name not in api_map:
        api_map[api_name] = {}
    if api_version not in api_map[api_name]:
        api_map[api_name][api_version] = {
            "name": api_name,
            "version": api_version,
            "paginator": None,
            "api": None,
            "paginator_file": None,
            "api_file": None
        }
    return api_map[api_name][api_version]


def find_files(api_dir):
    ret = {}
    files = os.listdir(api_dir)
    for f in files:
        full_path = os.path.join(api_dir, f)
        match = PAGINATOR_FORMAT.match(f)
        if match:
            entry = create_api_entry(ret, match.group(1), match.group(2))
            entry["paginator_file"] = full_path
        match = API_FORMAT.match(f)
        if match:
            entry = create_api_entry(ret, match.group(1), match.group(2))
            entry["api_file"] = full_path
    return ret


def build_all_files(outdir, api_dir):
    api_entries = find_files(api_dir)
    for api_name, versions in api_entries.items():
        for api_version, api_entry in versions.items():
            build_file(outdir, api_entry)
    build_route_file(outdir, api_entries)


if __name__ == '__main__':
    build_all_files(sys.argv[2], sys.argv[1])
